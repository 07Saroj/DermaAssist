# app/main.py
from fastapi import FastAPI, UploadFile, Form, HTTPException
from pydantic import BaseModel
from uuid import uuid4
from io import BytesIO
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from PIL import Image
import torch, torchvision.transforms as T
import httpx, os, json

app = FastAPI(title="DermAssist API")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")         # Meta Cloud API token or Twilio token
WHATSAPP_FROM  = os.getenv("WHATSAPP_FROM")          # WhatsApp Business phone ID or number
META_API_URL   = "https://graph.facebook.com/v21.0"

# ---- Mock model (replace with real checkpoint) ----
class_labels = ["tinea_corporis","acne_vulgaris","eczema","psoriasis","benign_naevus"]
model = torch.hub.load("pytorch/vision", "mobilenet_v3_small", pretrained=True)
model.classifier[3] = torch.nn.Linear(model.classifier[3].in_features, len(class_labels))
model.eval()

tx = T.Compose([
    T.Resize(256), T.CenterCrop(224),
    T.ToTensor(), T.Normalize([0.485,0.456,0.406],[0.229,0.224,0.225])
])

def softmax(x): return torch.nn.functional.softmax(x, dim=1)

# ---- In-memory store for demo ----
DB = {"studies":{}, "inferences":{}, "reports":{}}

class StudyResp(BaseModel):
    study_id: str

@app.post("/studies", response_model=StudyResp)
async def create_study(image: UploadFile, patient_phone_e164: str = Form(...)):
    if image.content_type not in ("image/jpeg","image/png"):
        raise HTTPException(415, "Only JPEG/PNG accepted")
    img_bytes = await image.read()
    study_id = str(uuid4())
    DB["studies"][study_id] = {"phone": patient_phone_e164, "img": img_bytes}
    return {"study_id": study_id}

@app.post("/inference/{study_id}")
async def run_inference(study_id: str):
    study = DB["studies"].get(study_id)
    if not study: raise HTTPException(404, "Study not found")

    img = Image.open(BytesIO(study["img"])).convert("RGB")
    with torch.no_grad():
        x = tx(img).unsqueeze(0)
        logits = model(x)
        probs = softmax(logits).squeeze().tolist()

    topk = sorted(zip(class_labels, probs), key=lambda t: t[1], reverse=True)[:3]
    top_label, top_prob = topk[0]
    status = "needs_review" if top_prob >= 0.8 else ("low_confidence" if top_prob < 0.5 else "needs_review")

    inf_id = str(uuid4())
    DB["inferences"][inf_id] = {
        "study_id": study_id, "top_label": top_label, "top_prob": top_prob, "topk": topk, "status": status
    }
    return {"inference_id": inf_id, "topk": topk, "status": status}

def render_pdf(patient_phone: str, topk, disclaimer: str) -> bytes:
    buf = BytesIO()
    c = canvas.Canvas(buf, pagesize=A4)
    w, h = A4
    c.setFont("Helvetica-Bold", 16)
    c.drawString(40, h-60, "DermAssist â€” Preliminary AI Report (Requires Clinician Review)")
    c.setFont("Helvetica", 11)
    c.drawString(40, h-90, f"Patient Phone: {patient_phone}")
    c.drawString(40, h-110, "Top Predictions:")
    y = h-130
    for label, p in topk:
        c.drawString(60, y, f"- {label.replace('_',' ').title()}: {p:.2%}")
        y -= 18
    c.drawString(40, y-10, "Notes:")
    c.setFont("Helvetica-Oblique", 10)
    text_obj = c.beginText(60, y-30)
    for line in disclaimer.split("\n"):
        text_obj.textLine(line)
    c.drawText(text_obj)
    c.showPage(); c.save()
    return buf.getvalue()

DISCLAIMER = (
  "This report is generated by an AI system and is NOT a medical diagnosis.\n"
  "A licensed clinician must review and approve any treatment or prescriptions.\n"
  "Seek urgent care if symptoms worsen, spread rapidly, involve fever, or pain."
)

@app.post("/reports/{inference_id}")
async def generate_report(inference_id: str):
    inf = DB["inferences"].get(inference_id)
    if not inf: raise HTTPException(404, "Inference not found")
    study = DB["studies"][inf["study_id"]]
    pdf_bytes = render_pdf(study["phone"], inf["topk"], DISCLAIMER)
    rep_id = str(uuid4())
    DB["reports"][rep_id] = {"inference_id": inference_id, "pdf": pdf_bytes, "approved": True}  # demo: auto-approve
    return {"report_id": rep_id}

@app.get("/reports/{report_id}/download")
async def download_report(report_id: str):
    rep = DB["reports"].get(report_id)
    if not rep: raise HTTPException(404, "Report not found")
    from fastapi.responses import Response
    return Response(rep["pdf"], media_type="application/pdf", headers={
        "Content-Disposition": f'attachment; filename="DermAssist_{report_id}.pdf"'
    })

@app.post("/reports/{report_id}/send-whatsapp")
async def send_whatsapp(report_id: str):
    rep = DB["reports"].get(report_id); 
    if not rep: raise HTTPException(404, "Report not found")
    inf = DB["inferences"][rep["inference_id"]]
    study = DB["studies"][inf["study_id"]]

    
    phone_id = WHATSAPP_FROM
    headers = {"Authorization": f"Bearer {WHATSAPP_TOKEN}"}

    async with httpx.AsyncClient(timeout=30) as client:
        upload = await client.post(
            f"{META_API_URL}/{phone_id}/media",
            headers=headers,
            files={"file": ("report.pdf", rep["pdf"], "application/pdf")},
            data={"messaging_product": "whatsapp"}
        )
        upload.raise_for_status()
        media_id = upload.json().get("id")

        # 2) Send document message
        payload = {
          "messaging_product": "whatsapp",
          "to": study["phone"],
          "type": "document",
          "document": {"id": media_id, "filename": "DermAssist_Report.pdf"}
        }
        msg = await client.post(f"{META_API_URL}/{phone_id}/messages", headers=headers, json=payload)
        msg.raise_for_status()
        rep["sent_via_whatsapp"] = True
        rep["whatsapp_msg_id"] = msg.json().get("messages",[{}])[0].get("id")

    return {"status": "sent", "whatsapp_msg_id": rep["whatsapp_msg_id"]}
